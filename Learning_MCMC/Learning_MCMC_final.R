

#learning MCMC final project
graphics.off()  #close plots
rm(list = ls()) #clear global env
cat("\014") #clear console


#parameters for mystery data generating function 
true_params_fun <- function(){
  trueA = 10
  trueB = 2
  trueC = 1
  trueSigma = 1
  params = list( a = trueA, b = trueB, c= trueC, sd = trueSigma )
  return(params)
}

trueParams = true_params_fun()
LengthData = 1000
tt = seq(0,1,length.out = LengthData)

# model 1 - linear
mysteryFunction_1 = function(p){
  y = p$a * tt  +  p$b
  return(y)
}

#model 2 - quadratic
mysteryFunction_2 = function(p){
  y = p$a * tt^2  +  p$b*tt  +  p$c 
  return(y)
}

#add stochastic component to model
stochMysteryFunction <- function(fun, p){
    y = fun(p) + rnorm(n = LengthData, mean = 0, sd = p$sd )
    return(y)
}

#data generated by stochastic mystery function 
Data = stochMysteryFunction(mysteryFunction_2, trueParams )
#plot the data
# plot(tt,Data)


#Log likelihood function. Gives -125.1104 for True values
logLikelihoodFun <- function(p){
  
  ## option 1:
  ## Use cost function (emperical likelihood). Returns -1.05 
  # cost =  (Data - mysteryFunction_2(p) )^2 
  # sumLik = -sum(cost)/length(cost)
  
  ## option 2: 
  ## Use formal likelihood (with explicit error structure). 
  # Better in case you have binary variables or what have you
  # returns -1392.077
  pred <- mysteryFunction_2(p)
  singlelikelihoods = dnorm(Data, mean = pred, sd = p$sd, log = T)
  sumLik = sum(singlelikelihoods) #/length(singlelikelihoods)
  return(sumLik)
}

# #plot the likelihoods for a range of values around the true values
# plot_a_likelihoods <- function(aa,true_params){
#     
#    a_liklihoods = function(aa){
#       p$a = aa
#       a_liks = logLikelihoodFun(p)
#       return(a_liks)
#     }
#     
#    p = true_params
#    a_list_likelihoods = lapply(aa,a_liklihoods)
#    plot(aa, a_list_likelihoods)
# }
# 
# plot_a_likelihoods( seq(0,20,length.out = 100), trueParams)


# Defining priors. 
# Their number and distributions depend on the particulars of the model
logPriors <- function(p){
  aprior = dunif(p$a, min = 9, max = 11, log=T)
  bprior = dunif(p$b, min = 1, max = 3, log = T)
  cprior = dunif(p$c, min = 0, max = 2, log = T)
  sdprior = dunif(p$d, min = 0, max = 2, log = T)
  return(aprior+bprior+cprior+sdprior)
}

#posterior is the product of the prior and the likelihood or their sum if logged
posteriors <- function(p){
  return( logLikelihoodFun(p) + logPriors(p) )
}

#TBD: need to make adaptive during burn-in
#in general should be narrower than priors
proposalFun <- function(p){
  y = rnorm(4, mean = c(p$a, p$b, p$c, p$sd), sd = c(.2,.2,.2,.2) )
  #make it so that the function returns the same column names as the call
  y = array(y,dim = c(1,length(p))) 
  colnames(y) <- colnames(p)
  y = data.frame(y)
  return(y)
}


runMCMC <- function(nRuns, startValues){
  #initialize the chain. It's a matrix with rows as runs and columns as variables
  NA_array = array(data = NA,dim = c(nRuns-1,length(startValues)) )
  colnames(NA_array) <- colnames(startValues)
  chain = rbind(startValues,NA_array)
  
  #iterate for the prescribed number of steps
  for (i in 1:nRuns){
    
    #draw a value from the proposal distribution
    proposal = proposalFun(chain[i,])
    
    prob = exp( logLikelihoodFun(proposal) - logLikelihoodFun(chain[i,]) )
    
    if (runif(1) < prob){
      chain[i+1,] = proposal
    }else{
      chain[i+1,] = chain[i,]
    }
    
  }
  
  return(chain)
}

initialGuess = data.frame(list( a = 1, b = 1, c = 1, sd = 1 ))
chain = runMCMC(25000, initialGuess )

burnIn = 5000
acceptance = 1 - mean(duplicated(chain[-(1:burnIn),]))
chainNoBurn = chain[-(1:burnIn),]


op <- par(no.readonly = TRUE)
par(mfrow = c(2,4))

hist(chain[-(1:burnIn),1],nclass=30, main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = trueParams[1], col="red" )

hist(chain[-(1:burnIn),2],nclass=30, main="Posterior of b", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),2]))
abline(v = trueParams[2], col="red" )


hist(chain[-(1:burnIn),3],nclass=30, main="Posterior of c", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),3]))
abline(v = trueParams[3], col="red" )


hist(chain[-(1:burnIn),4],nclass=30, main="Posterior of sd", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),4]) )
abline(v = trueParams[4], col="red" )

plot(chain[-(1:burnIn),1], type = "l", xlab="True value = red line" , main = "Chain values of a")
abline(h = trueParams[1], col="red" )

plot(chain[-(1:burnIn),2], type = "l", xlab="True value = red line" , main = "Chain values of b")
abline(h = trueParams[2], col="red" )

plot(chain[-(1:burnIn),3], type = "l", xlab="True value = red line" , main = "Chain values of c")
abline(h = trueParams[3], col="red" )

plot(chain[-(1:burnIn),4], type = "l", xlab="True value = red line" , main = "Chain values of sd")
abline(h = trueParams[4], col="red" )


#look at the joints
#pairs(data.frame(chain))





#get quantiles for posterior distributions
optimParams = quantile(chainNoBurn[,1])
for (i in 2:ncol(chainNoBurn)){
optimParams0 = quantile(chainNoBurn[,i])
optimParams = rbind(optimParams, optimParams0)
}
row.names(optimParams) <- colnames(chain)
optimParams = t(optimParams)
optimParams = data.frame(optimParams)
mode_params = optimParams[3,]

#look at the model fit to the data
# plot(tt,Data)
#lines(tt, mysteryFunction_2( mode_params) )

#random sample from all parameter simultaneously
nSubSample = 500
random_par = array(data = NA,dim = c(nSubSample,ncol(mode_params)) )
colnames(random_par) <- colnames(mode_params)
random_par = data.frame(random_par)

for (j in 1:ncol(mode_params)){
  random_par[,j] = sample(x = chainNoBurn[,j], replace = T, size = nSubSample)
}

plot.new()
par(op)
plot(tt,Data)
for (i in 1:nrow(random_par)){
  lines(tt, mysteryFunction_2(random_par[i,]))
   par(col = rgb(190, 190, 190, 50, maxColorValue = 255))
}



#################################################
#  now run analysis with linear mystery function
#################################################


#change likelihood function
logLikelihoodFun <- function(p){
  pred <- mysteryFunction_1(p)
  singlelikelihoods = dnorm(Data, mean = pred, sd = p$sd, log = T)
  sumLik = sum(singlelikelihoods) #/length(singlelikelihoods)
  return(sumLik)
}

#define new priors function
logPriors <- function(p){
  aprior = dunif(p$a, min = 9, max = 11, log=T)
  bprior = dunif(p$b, min = 1, max = 3, log = T)
  sdprior = dunif(p$sd, min = 0, max = 2, log = T)
  return(aprior + bprior + sdprior)
}

#new proposal function
proposalFun <- function(p){
  y = rnorm(4, mean = c(p$a, p$b, p$sd), sd = c(.2,.2,.2) )
  #make it so that the function returns the same column names as the call
  y = array(y,dim = c(1,length(p))) 
  colnames(y) <- colnames(p)
  y = data.frame(y)
  return(y)
}


initialGuess = data.frame(list( a = 1, b = 1, sd = 1 ))
chain = runMCMC(25000, initialGuess )


burnIn = 5000
acceptance = 1 - mean(duplicated(chain[-(1:burnIn),]))
chainNoBurn = chain[-(1:burnIn),]


par(op)
par(mfrow = c(2,3))

plot(density( chainNoBurn[,1]), main="Posterior of a", xlab="a")
plot(density( chainNoBurn[,2]), main="Posterior of b", xlab="b")
plot(density( chainNoBurn[,3]), main="Posterior of c", xlab="c")



plot(chainNoBurn[,1], type = "l", xlab="True value = red line" , main = "Chain values of a")
#abline(h = trueParams[1], col="red" )

plot(chainNoBurn[,2], type = "l", xlab="True value = red line" , main = "Chain values of b")
#abline(h = trueParams[2], col="red" )

plot(chainNoBurn[,3], type = "l", xlab="True value = red line" , main = "Chain values of sd")
#abline(h = trueParams[3], col="red" )



#look at the joints
#pairs(data.frame(chain))





#get quantiles for posterior distributions
optimParams = quantile(chainNoBurn[,1])
for (i in 2:ncol(chainNoBurn)){
  optimParams0 = quantile(chainNoBurn[,i])
  optimParams = rbind(optimParams, optimParams0)
}
row.names(optimParams) <- colnames(chain)
optimParams = t(optimParams)
optimParams = data.frame(optimParams)
mode_params = optimParams[3,]

#look at the model fit to the data
# plot(tt,Data)
#lines(tt, mysteryFunction_2( mode_params) )

#random sample from all parameter simultaneously
nSubSample = 500
random_par = array(data = NA,dim = c(nSubSample,ncol(mode_params)) )
colnames(random_par) <- colnames(mode_params)
random_par = data.frame(random_par)

for (j in 1:ncol(mode_params)){
  random_par[,j] = sample(x = chainNoBurn[,j], replace = T, size = nSubSample)
}

plot.new()
par(op)
plot(tt,Data)
for (i in 1:nrow(random_par)){
  lines(tt, mysteryFunction_1(random_par[i,]))
  par(col = rgb(190, 190, 190, 50, maxColorValue = 255))
}

#####
#which model is better supported?




