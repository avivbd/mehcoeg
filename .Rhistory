library(parallel)
library(scales)
library(readr)
require(stats)
library(parallel)
library(magrittr)
dev.off()
rm(list = ls())
# set.seed(1976)
source("./code/R/Sr_cycle/Sr_init.R")
source("./code/R/C_cycle/C_Cycle_init.R")
source("./code/R/General/PF.R")
p = C_Cycle_init()
q = Sr_init('y')
q = Sr_init('y')
p = C_Cycle_init()
p
source("../code/R/C_cycle/C_Cycle_init.R")
p = C_Cycle_init()
source("./code/R/C_cycle/C_Cycle_init.R")
p = C_Cycle_init()
library("MASS")
library(mvtnorm)
library(parallel)
library(scales)
library(readr)
require(stats)
library(parallel)
library(magrittr)
dev.off()
rm(list = ls())
# set.seed(1976)
source("./code/R/Sr_cycle/Sr_init.R")
source("./code/R/C_cycle/C_Cycle_init.R")
source("./code/R/General/PF.R")
p = C_Cycle_init()
q = Sr_init('y')
library("MASS")
library(mvtnorm)
library(parallel)
library(scales)
library(readr)
require(stats)
library(parallel)
library(magrittr)
dev.off()
rm(list = ls())
# set.seed(1976)
source("./code/R/Sr_cycle/Sr_init.R")
source("./code/R/C_cycle/C_Cycle_init.R")
source("./code/R/General/PF.R")
p = C_Cycle_init()
q = Sr_init('y')
state_eqs <- function (x, k){
t = q$t[1] + k*q$dt*1e-6
MC <- x[1]
MSr <- x[2]
RSr <- x[3]
F_forcing_v = x[4]
F_forcing_sw = x[5]
# F_forcing_sw = predict(q$ssp, t)$y
Fvolc = p$Fv*F_forcing_v
Fwsil = p$kws*MC*F_forcing_sw
# print(Fwsil)
dMC = Fvolc + p$Fwo - Fwsil - p$Fbo
dMSr = q$F_Sr_hydro_in + p$Fwcarb*q$k_Sr_Fwcarb +
Fwsil*q$k_Sr_Fwsil - q$F_Sr_hydro_out - q$k_Sr_bcarb*MSr
dRSr = (    q$F_Sr_hydro_in*(q$R_Sr_hydro_in - RSr) +
p$Fwcarb*q$k_Sr_Fwcarb*(q$R_Sr_wcarb  - RSr) +
Fwsil*q$k_Sr_Fwsil*(q$R_Sr_wsil - RSr))/MSr
# dMC = 0
# dMSr = 0
# dRSr = 0
dForcing_v = 0
dForcing_sw = 0
return(c((MC + q$dt*dMC), (MSr + q$dt*dMSr), (RSr + q$dt*dRSr),
(F_forcing_v + q$dt*dForcing_v), (F_forcing_sw + q$dt*dForcing_sw)) )}
obs_eqs <- function (x, k){
MC <- x[1]
RSr <- x[3]
F_forcing_sw <- x[5]
RCO2 = q$co2_conv(MC)
return(cbind(RSr, RCO2, F_forcing_sw))
}
#TODO put in a try catch box and restart if fails.
# zz = log10(c(1e7, 1e7, 1e-7, .05))
# best <- optim(zz, optim_fun, method = 'SANN',
# control = list(maxit = 20000, temp = 20))
# zz = c(1e10, 5e6, 1e-7, 1e-6, 1e-1)
zz = c(1e10, 5e6, 1e-7, 1e-2, 5e-1)
mod_pars <- list(m0=c(p$MCss, q$MSr,  q$RSr, 1, 1), #initial state estimates
C0=diag(1*zz),   #uncertainty of initial state estimates
V=diag(c(1e-3, 5e-1, 1e-3)),    #measurement noise
W=diag(zz))    #process noise
N_particles = 25000
# #about 1 minute
pf_results = PF(y=cbind(q$y_synth, q$pCO2_noisy, q$F_Forcing_ws_nsy),
mod=mod_pars, N=N_particles,
Nthreshold=floor(0.75*N_particles),
roughening=TRUE, GGfunction=state_eqs,
FFfunction=obs_eqs, MCparticles=TRUE)
tt = seq(q$t[1] - q$dt*1e-6, q$t %>% tail(.,1), by = q$dt*1e-6 )
l = length(tt)
results_to_mat <- function(pf_results, i){
matrix(unlist(lapply(pf_results$xpt, function(x) x[,i])), nrow=l, byrow=TRUE)}
MC_filt = results_to_mat(pf_results, 1)
MSr_filt = results_to_mat(pf_results, 2)
RSr_filt = results_to_mat(pf_results, 3)
F_forcing_v_filt = results_to_mat(pf_results, 4)
F_forcing_ws_filt = results_to_mat(pf_results, 5)
#95% ci for x
ci <- function(pf_results, i){
se = sqrt(unlist(lapply(pf_results$C, function(x) diag(x)[i])))
l = vector('list')
l$ci95 = pf_results$m[,i] + qnorm(.05/2)*se%o%c(1, -1)
l$ci65 = pf_results$m[,i] + qnorm(.35/2)*se%o%c(1, -1)
return(l)
}
ci_MC <- ci(pf_results, 1)
ci_MSr <- ci(pf_results, 2)
ci_RSr <- ci(pf_results, 3)
ci_FFv <- ci(pf_results, 4)
ci_FFws <- ci(pf_results, 5)
# layout(rbind(c(1,1, 2,2, 3,3), c(4,4,4, 5,5,5)))
par(mfrow=c(2,3))
plot(q$t, q$x_synth[, 1], ylab = 'MC', xlab='Age', ylim=(range(ci_MC$ci95)))
lines(tt, pf_results$m[,1], col='blue')
matlines(tt, ci_MC$ci95, lty=3, col="gray")
plot(q$t, q$x_synth[, 2], ylab = 'MSr', xlab='Age', ylim=range(ci_MSr$ci95))
lines(tt, pf_results$m[,2], col='blue')
matlines(tt, ci_MSr$ci95, lty = 3, col = 'gray')
plot(q$t, q$F_Forcing_v, ylab = 'F_Forcing_v', xlab='Age', ylim = range(ci_FFv$ci95))
lines(tt, pf_results$m[,4], col='blue')
matlines(tt, ci_FFv$ci95, lty = 3, col = 'gray')
plot(q$t, q$F_Forcing_ws_nsy, ylab = 'F_Forcing_ws', xlab='Age', ylim = range(ci_FFws$ci95))
lines(tt, pf_results$m[,5], col='blue')
matlines(tt, ci_FFws$ci95, lty = 3, col = 'gray')
plot(q$t, q$y_synth, ylab = 'RSr', ylim=(range(ci_RSr$ci95)))
lines(tt, pf_results$m[,3], col='blue')
matlines(tt, ci_RSr$ci95, lty=3, col="gray")
plot(q$t, q$pCO2_noisy, ylab = 'Temp', xlab='Age', ylim = range(q$co2_conv(ci_MC$ci95)))
lines(tt, q$co2_conv(pf_results$m[,1]), col='blue')
matlines(tt, q$co2_conv(ci_MC$ci95), lty=3, col="gray")
#---------
#plot full posterior distributions
n_trajectories = 20
pf_smooth = replicate(n_trajectories, PFsmooth(pf_results) )
MC_smooth = matrix(0, ncol=n_trajectories, nrow=l)
MSr_smooth = matrix(0, ncol=n_trajectories, nrow=l)
RSr_smooth = matrix(0, ncol=n_trajectories, nrow=l)
F_forcing_smooth = matrix(0, ncol=n_trajectories, nrow=l)
for (i in 1:n_trajectories){
MC_smooth[,i] = pf_smooth[i]$s[,1]
MSr_smooth[,i] = pf_smooth[i]$s[,2]
RSr_smooth[,i] = pf_smooth[i]$s[,3]
F_forcing_smooth[,i] = pf_smooth[i]$s[,4]
}
layout(rbind(c(1,1, 2,2, 3,3), c(4,4,4, 5,5,5)))
plot(q$t, q$x_synth[, 1], ylab = 'MC', xlab='Age')
# lines(tt, pf_results$m[,1], col='blue')
lines(tt, MC_smooth, col='red')
plot(q$t, q$x_synth[, 2], ylab = 'MSr', xlab='Age')
# lines(tt, pf_results$m[,2], col='blue')
lines(tt, MSr_smooth, col='red')
plot(q$t, q$F_Forcing_v, ylab = 'F_Forcing_v', xlab='Age')
# lines(tt, pf_results$m[,4], col='blue')
lines(tt, F_forcing_smooth, col='red')
plot(q$t, q$y_synth, ylab = 'RSr')
# lines(tt, pf_results$m[,3], col='blue')
lines(tt, RSr_smooth, col='red')
plot(q$t, q$pCO2_noisy, ylab = 'Temp', xlab='Age', ylim = c(16,40))
# lines(tt, q$TD*log2((pf_results$m[,1]/p$MCss)^2) + 20 , col='blue')
lines(tt, q$TD*log2((MC_smooth/p$MCss)^2) + 20, col='red' )
# start.time <- Sys.time()
# pf_smooth = replicate(5, PFsmooth(pf_results) )
# end.time <- Sys.time()
# time.taken <- end.time - start.time
# print(time.taken)
# clusterExport(cl,c("pf_results","p", "PFsmooth"))
#
# pf_smooth = parReplicate(cl, 5, PFsmooth(pf_results) )
#
#
Sr_init = function(plot_='n'){
#list of carbon cycle parameters
q = list()
#data
q$Sr_data <- read_csv("./Data/Sr_data.csv", col_types = 'dd')
q$Sr_spline <- read_csv("./Data/Sr_spline.csv", col_types = 'dd')
q$Temp_data <- read_csv("./Data/Temp_data.csv", col_types = 'dd')
#C-cycle params
source("./code/R/C_cycle/C_Cycle_init.R")
p = C_Cycle_init()
#reservoirs
q$MSr = 1.27e5 # Tmol, from Kump 87.
# results in a residence time of 2.2 Myr
#Sr fluxes
q$F_Sr_hydro_in = 2.5e-2# From Kump and Arthur 1997
q$F_Sr_hydro_out = 2.5e-2
q$F_Sr_wcarb = 2.5e-2 #from K+A 1997
q$F_Sr_wsil  = 0.25*q$F_Sr_wcarb #from K+A 1997
q$F_Sr_bcarb = q$F_Sr_wcarb + q$F_Sr_wsil
#Sr values
q$R_Sr_hydro_in = 0.7035
q$R_Sr_wsil = 0.7164 #
q$R_Sr_wcarb = 0.7080 # carbonate weathering from Kump and Arthur 1997
q$RSr = (q$F_Sr_hydro_in*q$R_Sr_hydro_in + q$F_Sr_wsil*q$R_Sr_wsil + q$F_Sr_wcarb*q$R_Sr_wcarb)/
(q$F_Sr_hydro_in+q$F_Sr_wcarb+q$F_Sr_wsil)
#sensitivities
q$k_Sr_Fwcarb = q$F_Sr_wcarb/p$Fwcarb
q$k_Sr_Fwsil = q$F_Sr_wsil/p$Fws
q$k_Sr_bcarb = q$F_Sr_bcarb/q$MSr
#observation errors
q$sigma_RSr = 1e-7
q$R = matrix(q$sigma_RSr^2)
#make synthetic data
state_eqs0 <- function (x, k, F_Forcing_v, F_Forcing_ws, dt){
MC <- x[1]
MSr <- x[2]
RSr <- x[3]
Fvolc = p$Fv*F_Forcing_v
Fwsil = p$kws*MC*F_Forcing_ws
dMC = Fvolc + p$Fwo - Fwsil - p$Fbo
dMSr = q$F_Sr_hydro_in + p$Fwcarb*q$k_Sr_Fwcarb + Fwsil*q$k_Sr_Fwsil - q$F_Sr_hydro_out - q$k_Sr_bcarb*MSr
dRSr = (        q$F_Sr_hydro_in*(q$R_Sr_hydro_in - RSr) +
p$Fwcarb*q$k_Sr_Fwcarb*(q$R_Sr_wcarb  - RSr) +
Fwsil*q$k_Sr_Fwsil*(q$R_Sr_wsil - RSr))/MSr
return(c((MC + dt*dMC),
(MSr + dt*dMSr),
(RSr + dt*dRSr)) )}
#make forcing for synthetic data
q$n = 100
q$t = seq(-257, -235, length.out = q$n )
midp_v = 20
q$TD = 3
q$F_Forcing_v = #matrix(1, q$n)
c(1 + 1.5/(1+exp(-10*(q$t[1:midp_v] + 254))),
1.5 + 1/(1+exp(1*(q$t[(midp_v+1):q$n] + 249))))
midp_ws = 20
q$F_Forcing_ws = #matrix(1, q$n)
c(1 - 1/(1.5 + exp(-10*(q$t[1:midp_ws] + 254))),
1 - 1/(1.5 + exp(1*(q$t[(midp_ws+1):q$n] + 249))))
q$F_Forcing_ws_nsy = q$F_Forcing_ws + rnorm(q$n, 0, 1e-1)
q$ssp = smooth.spline(x=q$t, y=q$F_Forcing_ws)
q$dt = mean(diff(q$t))*1e6
q$x_synth = matrix(ncol=3, nrow=q$n)
q$x_synth[1,] = c(p$MCss, q$MSr,  q$RSr[1])
for (k in 1:(q$n-1) ){
q$x_synth[k+1,] = state_eqs0(q$x_synth[k,], k, q$F_Forcing_v[k], q$F_Forcing_ws[k], q$dt)
}
#produce noisy observations
q$y_synth = matrix(q$x_synth[, 3] + rnorm(q$n, 0, 1e-4))
q$co2_conv <- function(MC){q$TD*log2((MC/p$MCss)^2) + 20}
q$pCO2 = q$co2_conv(q$x_synth[,1])
q$pCO2_noisy = q$pCO2 + rnorm(q$n, 0, 2e0)
if (plot_=='y'){
#plot synthetic data and the states that result in it
# layout(rbind(c(1,1, 2,2, 3,3), c(4,4,4, 5,5,5)))
par(mfrow=c(2,3))
plot(q$t, q$x_synth[, 1], ylab = 'MC', xlab='Age')
plot(q$t, q$x_synth[, 2], ylab = 'MSr', xlab='Age')
plot(q$t, q$F_Forcing_v, ylab = 'F_Forcing_v', xlab='Age')
plot(q$t, q$F_Forcing_ws_nsy, ylab = 'F_Forcing_ws', xlab='Age')
plot(q$t, q$x_synth[, 3], ylab = 'RSr', xlab='Age', type = 'l', ylim=c(0.7065, 0.7085))
points(q$t, q$y_synth , cex=0.5, col='black')
points(q$Sr_data$AGE, q$Sr_data$RSr, col='red')
plot(q$t, q$pCO2_noisy, 'p', cex=0.5, col='black', ylim = c(16,40))
lines(q$t, q$pCO2, col='black')
points(q$Temp_data$AgeTemp, q$Temp_data$Temp, col='red')
}
return(q)
}
#set up for parallel computation
# # Calculate the number of cores
# no_cores <- detectCores() - 1
#
# # Initiate cluster
# cl <- makeCluster(no_cores)
#
# #source the aux code for the cluster
# clusterCall(cl, function() { source(("./PF.R")) })
#
# #parallel replicate function
# parReplicate <- function(cl, n, expr, simplify=TRUE, USE.NAMES=TRUE){
#     parSapply(cl, integer(n), function(i, ex) eval(ex, envir=.GlobalEnv),
#               substitute(expr), simplify=simplify, USE.NAMES=USE.NAMES)
# }
#
C_Cycle_init = function(){
#list of carbon cycle parameters
p = list()
#time series attributes
p$t0 = 0
p$tf = 6e6
p$dt = 5e4
p$tt = seq(from=p$t0, to=p$tf, by=p$dt )
p$nt = length(p$tt)
#reservoirs
p$MCss = 3.8e6 #Tmol
p$MPss = 2e3
#fluxes
p$total_input = 50 #Tmol/yr
p$fworg = 0.2
p$forg = 0.2
p$Fv = 5
p$Fwo = 9
p$Fwcarb = 36
p$Fwp = 3.6e-2
p$Fbp = 3.6e-2
p$pCO2 = 540 #ppm
p$P = 2 #muM
p$Fws = (1-p$forg)*p$Fv
p$Fbo = p$Fwo + p$forg*p$Fv
p$Fbcarb = p$Fwcarb + p$Fws
#isotope values
p$eps = 28
p$d13C_volc = -5
p$delC = p$d13C_volc + p$forg*p$eps
p$delwo = p$delC - p$eps
#initial states
p$M0 = c(p$MPss, p$MCss, p$delC, 1)
#sensitivities
p$kws = p$Fws/p$MCss
p$kbc = p$Fbcarb/p$MCss
p$kbo = p$Fbo/p$MPss
p$kbp = p$Fbp/p$MPss
p$kwp = p$Fwp/p$MCss
p$kCO2 = p$pCO2/p$MCss
p$kP = p$P/p$MPss
#state variances
p$sigma_MP = 0.075*p$MPss
p$sigma_MC = 0.075*p$MCss
# p$sigma_delC = 0.5*p$delC
# p$sigma_Fv = 0.01*p$Fv
# p$Q = diag(c(p$sigma_MP^2, p$sigma_MC^2, 0.001, 0.005))
p$Q = diag(c(p$sigma_MP^2, p$sigma_MC^2, 1, 0.05))
#observation errors
p$sigma_d13C = 5*p$delC
# p$sigma_pCO2 = 0.5*p$pCO2
# p$sigma_P = 0.5*p$P
p$R = matrix(p$sigma_d13C^2)
p$W = function(){mvrnorm(n = 1, mu = matrix(0,1,dim(p$Q)[2]), Sigma = p$Q)}
p$V = function(){mvrnorm(n = 1, mu = matrix(0,1,dim(p$R)[2]), Sigma = p$R)}
p$Q_sample = diag(c(p$sigma_MP^2, p$sigma_MC^2, 0, 0.1))
p$R_sample = 0.5*p$delC
#forcing functions for synthetic data
# p$F_fun_d13C = function(t) (1 + 3*sin(1*pi*t/1e6) )
p$F_forcing  = function(t) (1 + 10e-1*sin(-1*pi*t/1e6) )
#ensemble characteristics
p$n_ensemble = 1000
p$n_trajectories = 50
return(p)
}
library("MASS")
library(mvtnorm)
library(parallel)
library(scales)
graphics.off()
rm(list = ls())
set.seed(1976)
source("./code/R/C_cycle/C_Cycle_init.R")
source("./code/R/General/PF.R")
# preliminaries ----
#set up for parallel computation
# Calculate the number of cores
no_cores <- detectCores() - 1
# Initiate cluster
cl <- makeCluster(no_cores)
#source the aux code for the cluster
clusterCall(cl, function() { source(("./PF.R")) })
#define model and observation equations with a known forcing
state_eqs0 <- function (x, k){
MP <- x[1]
MC <- x[2]
delC <- x[3]
F_forcing <- x[4]
c(
MP + p$dt*(p$kwp*MC - p$kbp*MP),
MC + p$dt*(p$Fv + p$Fwo - p$kws*MC - p$kbo*p$F_forcing(k*p$dt)*MP),
delC + p$dt*((p$Fv*(p$d13C_volc - delC) + p$Fwo*(p$delwo - delC) +
p$Fwcarb*(p$delC - delC) + p$kbo*MP*p$eps )/MC),
1
)}
#define equations that determine observability
obs_eqs <- function (x, k){
MP = x[1]
MC = x[2]
delC = x[3]
F_forcing = x[4]
return(delC)
}
#noise
W = function(){mvrnorm(n = 1, mu = matrix(0,1,dim(p$Q)[2]), Sigma = p$Q_sample)}
V = function(){mvrnorm(n = 1, mu = matrix(0,1,dim(p$R)[2]), Sigma = p$R_sample)}
#preallocate
x = matrix(0, ncol=dim(p$Q)[2], nrow=p$nt)
y = matrix(0, ncol=dim(p$R)[2], nrow=p$nt)
#initial values
x[1,] = p$M0
#make some synthetic data
for (k in 1:(p$nt-1)){
x[k+1,] = state_eqs0(x[k,], k) + W()
y[k+1] = obs_eqs(x[k+1,], k)  + V()
}
# #visualize states and observations
# plot(p$tt/1e6, y, type = "p", xlab = "Time [Myr]", ylab = expression(paste("δ"^"13"*"C" )) )
# plot(p$tt/1e6, x[,1], "b", xlab = "Time [Myr]", ylab = "MP")
# plot(p$tt/1e6, x[,2], "b", xlab = "Time [Myr]", ylab = "MC")
# plot(p$tt, p$F_forcing(p$tt), "b", xlab = "Time [Myr]", ylab = "Forcing")
#apply the particle filter ----
#redefine the state equations and now let the forcing be an unkown
state_eqs <- function (x, k){
MP <- x[1]
MC <- x[2]
delC <- x[3]
F_forcing <- x[4]
c(
MP + p$dt*(p$kwp*MC - p$kbp*MP),
MC + p$dt*(p$Fv + p$Fwo - p$kws*MC - p$kbo*F_forcing*MP),
delC + p$dt*((p$Fv*(p$d13C_volc - delC) + p$Fwo*(p$delwo - delC) +
p$Fwcarb*(p$delC - delC) + p$kbo*MP*p$eps )/MC),
F_forcing
)}
#particle filter
mod_pars <- list(m0=p$M0, #initial state estimates
C0=p$Q,   #uncertainty of initial state estimates
V=p$R,    #measurement noise
W=p$Q)    #process noise
pf_results = PF(y=y, mod=mod_pars, N=p$n_ensemble, resampling="strat", Nthreshold=p$n_ensemble/2,
roughening=TRUE, Grough=.2,
GGfunction=state_eqs, FFfunction=obs_eqs, MCparticles=TRUE)
# Apply particle smoother ----
#run smoother in serial
# pf_smooth <- replicate(p$n_trajectories, PFsmooth(pf_results))
#run smoother in parallel for a bit of speedup
parReplicate <- function(cl, n, expr, simplify=TRUE, USE.NAMES=TRUE){
parSapply(cl, integer(n), function(i, ex) eval(ex, envir=.GlobalEnv),
substitute(expr), simplify=simplify, USE.NAMES=USE.NAMES)
}
clusterExport(cl,c("pf_results","p", "PFsmooth"))
pf_smooth = parReplicate(cl, p$n_trajectories, PFsmooth(pf_results) )
MP_smooth = matrix(0, ncol=p$n_trajectories, nrow=p$nt+1)
MC_smooth = matrix(0, ncol=p$n_trajectories, nrow=p$nt+1)
delC_smooth = matrix(0, ncol=p$n_trajectories, nrow=p$nt+1)
F_forcing_smooth = matrix(0, ncol=p$n_trajectories, nrow=p$nt+1)
for (i in 1:p$n_trajectories){
MP_smooth[,i] = pf_smooth[i]$s[,1]
MC_smooth[,i] = pf_smooth[i]$s[,2]
delC_smooth[,i] = pf_smooth[i]$s[,3]
F_forcing_smooth[,i] = pf_smooth[i]$s[,4]
}
# plotting ----
plot(p$tt/1e6, x[,1], type="p", pch=16, col="black", xlab = "Time [Myr]", ylab = "MP")
matlines(c(0, p$tt)/1e6, MP_smooth, col= gray(0.5, 0.8), lty=3 )
lines(c(0,p$tt)/1e6, pf_results$m[,1], lty=2, col="blue", lwd=3)
lines(c(0, p$tt)/1e6, apply(MP_smooth, 1, median), lty=2, col="red", lwd=3)
legend("topleft", col=c("black", "blue", "red", "gray"),
lty=c(NA, 2, 2, 2), pch=c(16, NA, NA, NA), lwd=c(NA, 2, 2, 1),
legend=c("true state", "filtered PF", "smoothed PF", "particle trajectories"),
bty="n", y.intersp=1.2, cex=.7)
plot(p$tt/1e6, x[,2], type="p", pch=16, col="black", xlab = "Time [Myr]", ylab = "MC")
lines(c(0,p$tt)/1e6, pf_results$m[,2], lty=2, col="blue", lwd=3)
matlines(c(0, p$tt)/1e6, MC_smooth, col= gray(0.5, 0.8), lty=3 )
lines(c(0, p$tt)/1e6, apply(MC_smooth, 1, median), lty=2, col="red", lwd=3)
legend("topleft", col=c("black", "blue", "red", "gray"),
lty=c(NA, 2, 2, 2), pch=c(16, NA, NA, NA), lwd=c(NA, 2, 2, 1),
legend=c("true state", "filtered PF", "smoothed PF", "particle trajectories"),
bty="n", y.intersp=1.2, cex=.7)
plot(p$tt/1e6, p$F_forcing(p$tt), type="p", pch=16, col="black", xlab = "Time [Myr]", ylab = "Forcing")
lines(c(0,p$tt)/1e6, pf_results$m[,4], lty=2, col="blue", lwd=3)
matlines(c(0, p$tt)/1e6, F_forcing_smooth, col= gray(0.5, 0.8), lty=3 )
lines(c(0, p$tt)/1e6, apply(F_forcing_smooth, 1, median), lty=2, col="red", lwd=3)
legend("topleft", col=c("black", "blue", "red", "gray"),
lty=c(NA, 2, 2, 2), pch=c(16, NA, NA, NA), lwd=c(NA, 2, 2, 1),
legend=c("true state", "filtered PF", "smoothed PF", "particle trajectories"),
bty="n", y.intersp=1.2, cex=.7)
plot(p$tt/1e6, y, type="p", pch=16, col="black", xlab = "Time [Myr]", ylab = "Forcing")
lines(c(0,p$tt)/1e6, pf_results$m[,3], lty=2, col="blue", lwd=3)
matlines(c(0, p$tt)/1e6, delC_smooth, col= gray(0.5, 0.8), lty=3 )
lines(c(0, p$tt)/1e6, apply(delC_smooth, 1, median), lty=2, col="red", lwd=3)
legend("topleft", col=c("black", "blue", "red", "gray"),
lty=c(NA, 2, 2, 2), pch=c(16, NA, NA, NA), lwd=c(NA, 2, 2, 1),
legend=c("true state", "filtered PF", "smoothed PF", "particle trajectories"),
bty="n", y.intersp=1.2, cex=.7)
library(readr)
Sr_data <- read_csv("Data/Sr_data.csv")
View(Sr_data)
plot(Sr_data$AGE, Sr_data$RSr)
library(readr)
Sr_spline <- read_csv("Data/Sr_spline.csv")
View(Sr_spline)
plot(Sr_spline$AGE, Sr_spline$RSr)
plot(Sr_spline$Age, Sr_spline$RSr)
library(readr)
Sun_d13C_Data <- read_csv("Data/Sun_d13C_Data.csv")
View(Sun_d13C_Data)
library(readr)
Temp_data <- read_csv("Data/Temp_data.csv")
View(Temp_data)
plot(Temp_data$AgeTemp, Temp_data$Temp)
plot(Sun_d13C_Data$Aged13C, Sun_d13C_Data$d13C)
plot(Temp_data$AgeTemp, Temp_data$Temp)
plot(Sr_spline$Age, Sr_spline$RSr)
plot(Sun_d13C_Data$Aged13C, Sun_d13C_Data$d13C)
plot(Temp_data$AgeTemp, Temp_data$Temp)
plot(Temp_data$AgeTemp, Temp_data$Temp, Sun_d13C_Data$Aged13C, Sun_d13C_Data$d13C)
plotyy(Temp_data$AgeTemp, Temp_data$Temp, Sun_d13C_Data$Aged13C, Sun_d13C_Data$d13C)
plot(Temp_data$AgeTemp, Temp_data$Temp)
lines(Sun_d13C_Data$Aged13C, Sun_d13C_Data$d13C)
plot(Temp_data$AgeTemp, Temp_data$Temp)
par(new=TRUE)
plot(Sun_d13C_Data$Aged13C, Sun_d13C_Data$d13C)
